<!DOCTYPE html><html><head><title>R: Translate an R function into C++</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>translate</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Translate an R function into C++</h2>

<h3>Description</h3>

<p><code>translate()</code> compiles an R function into C++ code using the
<em>ast2ast</em> expression template library. The result can be called
directly from R (default) or returned as an external pointer. The C++
source code can also be retrieved without compilation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(
  f,
  args_f = NULL,
  output = "R",
  derivative = NULL,
  verbose = FALSE,
  getsource = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f">f</code></td>
<td>
<p>An R function to be translated into C++.</p>
</td></tr>
<tr><td><code id="args_f">args_f</code></td>
<td>
<p>A helper function that defines the types of the arguments of <code>f</code>.
Optional; defaults to <code>NULL</code>. See the Details section.</p>
</td></tr>
<tr><td><code id="output">output</code></td>
<td>
<p>Controls what is returned:
</p>

<ul>
<li> <p><code>"R"</code> (default): an R function wrapping the compiled C++.
</p>
</li>
<li> <p><code>"XPtr"</code>: an external pointer to the compiled C++ function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="derivative">derivative</code></td>
<td>
<p>When derivatives are required one can set here the mode of the automatic differentiation:
</p>

<ul>
<li> <p><code>NULL</code> (default): You don't require any derivatives.
</p>
</li>
<li> <p><code>"forward"</code> Determine the derivatives via forward automatic differentiation.
</p>
</li>
<li> <p><code>"reverse"</code> Determine the derivatives via reverse automatic differentiation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints output from the compilation process.</p>
</td></tr>
<tr><td><code id="getsource">getsource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns the generated C++ source code as a string instead of compiling it.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Supported functions</h4>

<p>The following R constructs are currently supported:
</p>

<ol>
<li><p> Assignment: <code>=</code> and <code>&lt;-</code>
</p>
</li>
<li><p> Allocation: <code>vector</code>, <code>matrix</code>, <code>rep</code>, <code>logical</code>, <code>integer</code>, <code>numeric</code>
</p>
</li>
<li><p> Object info: <code>length</code>, <code>dim</code>
</p>
</li>
<li><p> Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>
</p>
</li>
<li><p> Indexing: <code>[]</code> and <code>[[]]</code>
</p>
</li>
<li><p> Math: <code>sin</code>, <code>asin</code>, <code>sinh</code>, <code>cos</code>, <code>acos</code>, <code>cosh</code>,
<code>tan</code>, <code>atan</code>, <code>tanh</code>, <code>sqrt</code>, <code>log</code>, <code>^</code>, <code>exp</code>
</p>
</li>
<li><p> Concatenation: <code>c</code>
</p>
</li>
<li><p> Control flow: <code>for</code>, <code>while</code>, <code>repeat</code>, <code>next</code>, <code>break</code>,
<code>if</code>, <code>else if</code>, <code>else</code>
</p>
</li>
<li><p> Comparison: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>
</p>
</li>
<li><p> Logical ops: <code>&amp;&amp;</code>, <code>||</code>, <code>&amp;</code>, <code>|</code>
</p>
</li>
<li><p> Printing: <code>print</code>
</p>
</li>
<li><p> Return: <code>return</code>
</p>
</li>
<li><p> Catmullâ€“Rom spline: <code>cmr</code>
</p>
</li>
<li><p> Sequence operator: <code>:</code>
</p>
</li>
<li><p> Helpers: <code>is.na</code>, <code>is.finite</code>, <code>is.infinite</code>
</p>
</li>
<li><p> Explicit typing: <code>type()</code>
</p>
</li>
<li><p> Derivative functions in forward mode: <code>seed</code>, <code>unseed</code>, and <code>get_dot</code>
</p>
</li>
<li><p> Derivative functions in reverse mode: <code>deriv</code>
</p>
</li></ol>

<p>Types are static in C++ and cannot be changed within the function. Each type consists of a base data type and a data structure:
</p>

<ul>
<li><p> Base types: <code>logical</code>, <code>integer</code> (or <code>int</code>), <code>double</code>
</p>
</li>
<li><p> Structures: <code>scalar</code>, <code>vector</code> (or <code>vec</code>), <code>matrix</code> (or <code>mat</code>)
</p>
</li></ul>

<p>Types are usually inferred automatically. Users may annotate explicitly, for example:
</p>
<pre>
      a |&gt; type(logical)      # scalar logical
      b |&gt; type(vec(int))     # integer vector
      c |&gt; type(mat(double))  # double matrix
    </pre>
<p>Scalars in ast2ast differ from R: in R, scalars are length-1 vectors, but in C++ they are true scalars and cannot be subset.
</p>



<h4>Argument types</h4>

<p>Arguments default to <code>matrix(double)</code> if <code>args_f</code> is <code>NULL</code>.
To override, supply a function that annotates each argument:
</p>
<pre>
      f_args &lt;- function(a, b, c) {
        a |&gt; type(borrow_vec(double)) |&gt; ref()
        b |&gt; type(borrow_mat(double)) |&gt; ref() |&gt; const()
        c |&gt; type(double) |&gt; ref()
      }
    </pre>
<p>Supported extensions for arguments:
</p>

<ul>
<li> <p><code>borrow_vec</code>, <code>borrow_mat</code>: pass inputs by reference, modifying them in place.
</p>
</li>
<li> <p><code>const()</code>: disallow modification of inputs.
</p>
</li>
<li> <p><code>ref()</code>: pass by reference (only valid when <code>output = "XPtr"</code>).
</p>
</li></ul>




<h4>Derivatives</h4>

<p><code>ast2ast</code> supports automatic differentiation (AD) in two modes: forward
and reverse. The mode is selected via the <code>derivative</code> argument of
<code>translate()</code>.
</p>

<ul>
<li> <p><code>derivative = "forward"</code> enables forward-mode AD.
</p>
</li>
<li> <p><code>derivative = "reverse"</code> enables reverse-mode AD.
</p>
</li></ul>

<p>The AD system is intentionally low-level and explicit. Rather than providing
high-level wrappers (such as a built-in <code>jacobian()</code>), users are expected
to assemble derivative computations themselves using a small set of primitive
building blocks. This keeps the interface flexible, transparent, and close
to the generated C++ code.
</p>


<h5>Forward mode</h5>

<p>In forward mode, derivatives are propagated alongside values. The following
functions are available:
</p>

<ul>
<li> <p><code>seed(x, i)</code>: marks the <code>i</code>-th component of <code>x</code> as the
active direction (sets its derivative to 1).
</p>
</li>
<li> <p><code>unseed(x, i)</code>: resets the derivative state of the <code>i</code>-th
component.
</p>
</li>
<li> <p><code>get_dot(y)</code>: extracts the derivative (dot) values of <code>y</code>.
</p>
</li></ul>

<p>A typical pattern is to loop over input dimensions, seed one component at a
time, evaluate the function, extract derivatives using <code>get_dot()</code>, and
assemble the Jacobian manually.
</p>



<h5>Reverse mode</h5>

<p>In reverse mode, derivatives are accumulated by backpropagation from outputs
to inputs. The function
</p>

<ul>
<li> <p><code>deriv(y, x)</code>
</p>
</li></ul>

<p>computes the Jacobian of <code>y</code> with respect to <code>x</code>. This call must
appear explicitly in the translated function. Reverse mode is particularly
efficient when the number of outputs is small relative to the number of inputs.
</p>



<h5>Design philosophy</h5>

<p>Derivative computation in <code>ast2ast</code> is explicit by design. The full control
flow (including loops, seeding, unseeding, and accumulation) is visible in the
user code and translated directly into C++. This makes the generated code easy
to inspect, reason about, and modify, and avoids hidden performance costs.
<strong>Important:</strong> The <code>derivative</code> argument only enables the AD
infrastructure. It does not automatically differentiate your function. You
must explicitly call <code>seed()</code>, <code>unseed()</code>, <code>get_dot()</code>, or
<code>deriv()</code> inside your function, depending on the chosen mode.
</p>


<p><strong>Note:</strong> The generated C++ mimics R semantics closely but not exactly.
Always validate compiled functions against the original R implementation before
using in production. See the vignette <em>Detailed Documentation</em> for a
full comparison, and <em>InformationForPackageAuthors</em> for internals.
</p>


<h3>Value</h3>

<p>Depending on <code>output</code>:
</p>

<ul>
<li> <p><em>R</em>: an R function that directly calls the compiled C++ code.
</p>
</li>
<li> <p><em>XPtr</em>: a function that returns an external pointer to the compiled C++ code.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Hello World
# ----------------------------------------------------------------
f &lt;- function() {
  print("Hello World!")
}
f_cpp &lt;- ast2ast::translate(f)
f_cpp()

# Derivatives
# ----------------------------------------------------------------
f &lt;- function(y, x) {
  y[[1L]] &lt;- x[[1L]] * x[[2L]]
  y[[2L]] &lt;- x[[1L]] + x[[2L]]*x[[2L]]
  jac &lt;- deriv(y, x)
  return(jac)
}
fcpp_reverse &lt;- ast2ast::translate(f, derivative = "reverse")
y &lt;- c(0, 0)
x &lt;- c(2, 3)
fcpp_reverse(y, x)

f &lt;- function(y, x) {
  jac &lt;- matrix(0.0, length(y), length(x))
  for (i in 1L:length(x)) {
    seed(x, i)
    y[[1L]] &lt;- x[[1L]] * x[[2L]]
    y[[2L]] &lt;- x[[1L]] + x[[2L]]*x[[2L]]
    d &lt;- get_dot(y)
    jac[TRUE, i] &lt;- d
    unseed(x, i)
  }
  return(jac)
}
fcpp_forward &lt;- ast2ast::translate(f, derivative = "forward")
fcpp_forward(y, x)

# Bubble sort (using [[ for scalars)
# ----------------------------------------------------------------
bubble &lt;- function(a) {
  size &lt;- length(a)
  for (i in 1:size) {
    for (j in 1:(size - 1)) {
      if (a[[j]] &gt; a[[j + 1]]) {
        temp &lt;- a[[j]]
        a[[j]] &lt;- a[[j + 1]]
        a[[j + 1]] &lt;- temp
      }
    }
  }
  return(a)
}
bubble_cpp &lt;- ast2ast::translate(bubble)
bubble_cpp(runif(10))

# Fibonacci sequence
# ----------------------------------------------------------------
fib &lt;- function(n = 10) {
  f &lt;- integer(n)
  f[[1L]] &lt;- 1L
  f[[2L]] &lt;- 1L
  for (i in 3L:n) {
    f[i] &lt;- f[i-1L] + f[i-2L]
  }
  return(f)
}
fib_cpp &lt;- ast2ast::translate(fib)
fib_cpp(10)

# External pointer interface
# ----------------------------------------------------------------
f &lt;- function() {
  print("Hello World from C++")
}
ptr &lt;- ast2ast::translate(f, output = "XPtr")

# Call from C++ side
Rcpp::sourceCpp(code = "
  #include &lt;Rcpp.h&gt;
  typedef void (*fp)();
  // [[Rcpp::export]]
  void call_fct(Rcpp::XPtr&lt;fp&gt; inp) {
    fp f = *inp;
    f();
  }")
call_fct(ptr)


## End(Not run)</code></pre>

</main>

</div>
</body></html>
