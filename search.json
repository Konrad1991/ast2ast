[{"path":"/CodeofConduct.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"contributing repository, please first discuss change wish make via issue, email, method owners repository making change. Please note code conduct, please follow interactions project.","code":""},{"path":"/CodeofConduct.html","id":"pull-request-process","dir":"","previous_headings":"","what":"Pull Request Process","title":"Contributing","text":"Ensure install build dependencies removed end layer build. Update README.md details changes interface, includes new environment variables, exposed ports, useful file locations container parameters. Increase version numbers examples files README.md new version Pull Request represent. versioning scheme use SemVer. may merge Pull Request sign-two developers, permission , may request second reviewer merge .","code":""},{"path":[]},{"path":"/CodeofConduct.html","id":"our-pledge","dir":"","previous_headings":"Code of Conduct","what":"Our Pledge","title":"Contributing","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, gender identity expression, level experience, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"/CodeofConduct.html","id":"our-standards","dir":"","previous_headings":"Code of Conduct","what":"Our Standards","title":"Contributing","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CodeofConduct.html","id":"our-responsibilities","dir":"","previous_headings":"Code of Conduct","what":"Our Responsibilities","title":"Contributing","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"/CodeofConduct.html","id":"scope","dir":"","previous_headings":"Code of Conduct","what":"Scope","title":"Contributing","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"/CodeofConduct.html","id":"enforcement","dir":"","previous_headings":"Code of Conduct","what":"Enforcement","title":"Contributing","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team konrad_kraemer@yahoo.de . complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"/CodeofConduct.html","id":"attribution","dir":"","previous_headings":"Code of Conduct","what":"Attribution","title":"Contributing","text":"Code Conduct adapted Contributor Covenant, version 1.4, available http://contributor-covenant.org/version/1/4","code":""},{"path":[]},{"path":"/Readme.html","id":"news","dir":"","previous_headings":"","what":"News","title":"R package ast2ast","text":"see : https://konrad1991.github.io/ast2ast/index.html 11-04-2023: version 0.3.1 now CRAN gave talk useR! 2022 conference ast2ast. record can watched using following link: https://m.youtube.com/watch?v=5NDPOLunQTA&list=PL77T87Q0eoJjvKVFHuJZ5_BGVbPPpB8LL&index=8,","code":""},{"path":"/Readme.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"R package ast2ast","text":"Translates R function C++ function. external pointer C++ function R function returned user. install Github version package use devtools::install_github(“Konrad1991/ast2ast”, build_vignettes = TRUE). package also CRAN can installed via install.packages(“ast2ast”). motivation write package often cumbersome using R functions applications call R function often (> 100 calls) (e.g. ODE solving, Optimization). One possiblity write function faster programming language e.g. C. However, learning languages C difficult time consuming. Therefore ast2ast decent alternative function can written R. example solving simple ODE-System. translated code considerable faster R code almost fast C++. Code example can found vignettes.","code":""},{"path":"/Readme.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation:","title":"R package ast2ast","text":"See documentation function translate see use ast2ast: Function translate. want get details check: Detailed Documentation. case want use ast2ast packages, intersted ast2ast works internally, see Information package authors.","code":""},{"path":"/Readme.html","id":"contribution","dir":"","previous_headings":"","what":"Contribution","title":"R package ast2ast","text":"Contribution warmly appreciated (See Code Conduct).","code":""},{"path":"/articles/DetailedDocumentation.html","id":"documentation","dir":"Articles","previous_headings":"","what":"Documentation","title":"Detailed Documentation","text":"package ast2ast translates R function C++ function. Either external pointer (XPtr) R function returned. scope ast2ast generate functions can used solving ode-systems (derivative function jacobian function) optimization. generally, translated function can used fields necessary evaluate function often. Especially function evaluated C++ generated external pointer sufficient see benchmark . Within vignette functions supported ast2ast presented. examples presented using R output form. XPtr output differs described. First , supported objects functions listed explained detail. , arguments passed functions described explained function returns. Furthermore, function, small example given showing use . Moreover, explained function differs R equivalents. another differences detected please report . Supported objects: vectors (containing numbers) matrices (containing numbers) Supported functions: assignment: = <- allocation: vector matrix information objects: length dim Basic operations: +, -, *, / Indices: [] mathematical functions: sin, asin, sinh, cos, acos, cosh, tan, atan, tanh, log, ^ exp concatenate objects: c control flow: , , else , else comparison: ==, !=, >, <, >= <= printing: print returning objects: return .na .infinite can used test NA Inf. d-, p-, q- r-unif, -norm, -lnorm -gamma (gamma argument Scale defined calculated using 1/rate)","code":""},{"path":"/articles/DetailedDocumentation.html","id":"objects","dir":"Articles","previous_headings":"Documentation","what":"Objects","title":"Detailed Documentation","text":"exist two containers can used ast2ast functions. containers can hold numeric type R (equivalent double). first container vector second one matrix. possible declare variable scalar numeric data type. done adding _db (e.g. varname_db) end variable. time _db found variable declared scalar numeric data type. case, object change type! pivotal follow rules variable naming C++. instance, allowed use ‘.’ variable names. Features ast2ast variables can change type within function. usually possible using C++. index vectors matrices starts 1 R. index boundaries vector matrix. Even though different behavior R nice feature. access element outside boundaries vector R NA returned. memory matrices arranged column-wise R. using “R” output argument translate function expects SEXP objects. objects can modified long size increased (see Example 1). using “XPtr” output argument translate variables can passed reference. Meaning pass memory address object (called reference). , set reference parameter TRUE. pass function reference can modify object without returning . Notably, return used R code translated ast2ast nothing returned (R last object returned case). see x 10 call function 1 call function. function return anything. Thus, object x modified function without copying . Example 1 Caveats: Overhead generated due code injection. especially true “R” used output argument. Variables scalars represented vectors length 1. C++ scalar variables defined vectors speed translated R function can substantially lower compared native C++ function.","code":"f <- function(variable) {   variable <- 1 } library(ast2ast) fetr <- translate(f) x <- 10 return_value <- fetr(x) print(x) ## [1] 10 print(return_value) ## NULL"},{"path":"/articles/DetailedDocumentation.html","id":"variable-declaration","dir":"Articles","previous_headings":"Documentation","what":"Variable declaration","title":"Detailed Documentation","text":"Example 2 various ways declaring variables presented. assign value variable can use <- =. already mentioned numeric values possible. want assign vector can use either c vector function. c function works way R can handle combinations scalars, vectors matrices. function vector differs two ways R equivalent. First , use terms vector(length = size) possible C++. contrast, just write vector(size). R function rep available ast2ast possible write vector(value, size) R written rep(value, size). third way use vector function pass another vector size e.g. vector(other_vector, size). matrix function works way vector function. However, instead size, two arguments needed number rows number columns. Example 2","code":"f <- function() {   a <- 1   a_db <- 3.14   b <- 2   c <- c(1, 2, 3)   d <- vector_numeric(2)   e <- rep(3.14, 4)   f <- rep(c, 3)   g <- matrix(2, 2)   h <- matrix(6, 2, 2)   i <- matrix(e, 2, 2)    print(\"a\")   print(a)   print(a_db)   print()   print(\"b\")   print(b)   print()   print(\"c\")   print(c)   print()   print(\"d\")   print(d)   print()   print(\"e\")   print(e)   print()   print(\"f\")   print(f)   print()   print(\"g\")   print(g)   print()   print(\"h\")   print(h)   print()   print(\"i\")   print(i)   print() } library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"basic-arithmetics","dir":"Articles","previous_headings":"Documentation","what":"Basic arithmetics","title":"Detailed Documentation","text":"usual R possible use basic arithmetic operations scalars, vectors matrices (Example 3). Example 3","code":"f <- function() {   a <- 2   b <- 3   print(\"scalar operations\")   print(a + b)   print(a - b)   print(a / b)   print(a * b)    print()    print(\"vector & scalar operations\")   a <- c(1, 2, 3)   b <- 4   print(a + b)   print(b - a)    print()    print(\"2 vectors (same length)\")   a <- 6:8   b <- 1:3   print(a / b)   a <- 1:6   b <- 1:3   print(a / b)   print(\"2 vectors (different length)\")   print(\"multiple of each other\")   a <- 1:6   b <- 1:3   print(a / b)   print(\"not a multiple of each other\")   a <- 1:5   b <- 1:3   print(a / b) # different to R no warning    print()    print(\"matrix & scalar operations\")   a <- 3   b <- matrix(3, 2, 2)   print(a * b)   print(b + 4)    print()    print(\"matrix & vector operations\")   a <- 5:6   b <- matrix(3, 2, 2)   print(b - a)   print(a / b)    print()    print(\"matrix & matrix operations\")   a <- matrix(3, 2, 2)   b <- matrix(4, 2, 1)   print(a + b)    print()    print(\"mixed operations\")   a <- 1   b <- 2:5   c <- matrix(50, 2, 2)   d <- a + b - c / 2   print(d) }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"subsetting","dir":"Articles","previous_headings":"Documentation","what":"Subsetting","title":"Detailed Documentation","text":"want subset vector matrix object can use either [] function. [] slower powerful (Example 4). following objects can passed [] using vector matrix: nothing numeric scalar logical vector matrix result comparison case matrix, possible pass one objects access specific rows columns respectively ([rows, cols]). contrast [], function accepts scalar two scalars vectors matrices, respectively. Thus, single element accessed function! However, function works faster. result subsetted . function returns numeric type used variable declared extension _db. Example 4","code":"f <- function() {   print(\"pass nothing\")   a <- 1:8   print(a)   a[] <- 100   print(a)   print()    print(\"pass logical\")   a <- 1:8   print(a)   a[TRUE] <- 100   print(a)   print()    print(\"pass scalar\")   a <- 1:8   print(a)   a[1] <- 100   print(a)   print()     print(\"pass vector\")   a <- 1:8   b <- 2:5   print(a)   a[b] <- 100   print(a)   print()    print(\"pass result of ==\")   a <- 1:8   a[a < 5] <- 100   print(a)   print()     print(\"pass result of !=\")   a <- 1:8   b <- c(1, 2, 3, 0, 0, 0, 0, 8)   a[a != b] <- 100   print(a)   print()     print(\"pass result of <=\")   a <- 1:8   b <- c(1, 2, 3, 0, 0, 0, 0, 8)   a[a <= b] <- 100   print(a)   print()     print(\"pass result of >=\")   a <- 1:8   b <- c(1, 2, 3, 0, 0, 0, 0, 9)   a[a >= b] <- 100   print(a)   print()     print(\"pass result of >\")   a <- 1:8   b <- c(0, 2, 3, 0, 0, 0, 0, 9)   a[a > b] <- 100   print(a)   print()     print(\"pass result of <\")   a <- 1:8   b <- c(0, 2, 3, 0, 0, 0, 0, 9)   a[a < b] <- 100   print(a)   print()     print(\"pass scalar, scalar\")   a <- matrix(3, 4, 4)   a[1, 1] <- 100   print(a)   print()     print(\"pass vector, vector\")   a <- matrix(3, 4, 4)   b <- c(1, 3)   c <- c(2, 4)   a[b, c] <- 100   print(a)   print()     print(\"pass ==, >=\")   a <- matrix(1:16, 4, 4)   b <- 1:4   c <- c(1, 8, 3, 8)   a[b == c, b >= c] <- 100   print(a)   print()     print(\"at\")   a <- 1:16   at(a, 2) <- 100   print(a)   print()     print(\"at\")   a <- matrix(1:16, 4, 4)   at(a, 1, 4) <- 100   print(a)   print() }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"helper-functions","dir":"Articles","previous_headings":"Documentation","what":"Helper functions","title":"Detailed Documentation","text":"exist three helper function. length function returns number elements vector matrix. dim function returns number rows columns matrix. : function can used create range numbers. example 1:3 creates vector elements 1, 2 3 1.1:5.3 returns vector elements 1.1, 2.1, 3.1, 4.1 5.1. See Example 5 order see functions can applied. Example 5","code":"f <- function() {   a <- 1:4   print(a)   a <- 1.1:5.2   print(a)    a <- 1:16   print(length(a))    b <- matrix(1:4, 2, 2)   print(dim(b)) }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"comparison-functions","dir":"Articles","previous_headings":"Documentation","what":"Comparison functions","title":"Detailed Documentation","text":"usual R possible compare two objects using one following options (Example 6): == <= >= != < > Example 6","code":"f <- function() {   a <- 1:4   b <- c(1, 2, 3, 5)   c <- 9   print(a == b)   print(a <= b)   print(a >= b)   print(a != b)   print(a < c)   print(a > c) }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"control-flow","dir":"Articles","previous_headings":"Documentation","what":"Control flow","title":"Detailed Documentation","text":"possible write -loops ‘’, ‘else ’, ‘else’ branches native R (Example 7). (index variable){ # whatever } (index 1:length(variable){ # whatever } Example 7","code":"f <- function() {   a <- 1:4   for (i in a) {     print(i)   }    for (i in 1:length(a)) {     a[i] <- i + i   }    for (i in 1:length(a)) {     if (i < 4 && i > 1) {       print(i)     }   } }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"printing","dir":"Articles","previous_headings":"Documentation","what":"Printing","title":"Detailed Documentation","text":"Using function print common R (see Examples 2, 3, 4, 5, 6): print() different R print(“string”) print(logical) print(scalar) print(vector) different R print(matrix)","code":""},{"path":"/articles/DetailedDocumentation.html","id":"math-functions","dir":"Articles","previous_headings":"Documentation","what":"Math functions","title":"Detailed Documentation","text":"Following mathematical functions available (see Example 8): sin asin sinh cos acos cosh tan atan tanh sqrt log ^ exp d-, p-, q- r-unif, -norm, -lnorm -gamma (gamma argument Scale defined calculated using 1/rate) Example 8","code":"f <- function() {   a <- 1:4   print(sin(a))   print(cos(a))   print(a^2)   print(exp(a)) }  library(ast2ast) fetr <- translate(f) fetr()"},{"path":"/articles/DetailedDocumentation.html","id":"interpolation","dir":"Articles","previous_headings":"Documentation","what":"Interpolation","title":"Detailed Documentation","text":"interpolate values, ‘cmr’ function can used. function needs three arguments (see Example 9): first argument point independent variable (x) dependent variable calculated (y). vector length one. second argument vector defining points independent variable (x). vector least length four. third argument vector defining points dependent variable (y). vector least length four. Example 9","code":"f <- function() {   dep <- c(0, 1, 0.5, 2.5, 3.5, 4.5, 4)   indep <- 1:7   evalpoints <- c(     0.5, 1, 1.5, 2, 2.5,     3, 3.5, 4, 4.5, 5,     5.5, 6, 6.5   )   for (i in evalpoints) {     print(cmr(i, indep, dep))   } }  library(ast2ast) fetr <- translate(f, verbose = TRUE) fetr()"},{"path":"/articles/InformationForPackageAuthors.html","id":"guidance-for-package-authors","dir":"Articles","previous_headings":"","what":"Guidance for Package Authors","title":"Information for package authors","text":"section documentation describes external pointers C++ function produced ast2ast can used packages. information intended package authors want use translated functions within code. Additionally, section endeavors present pertinent implementation details, providing valuable insights inner workings process.","code":""},{"path":"/articles/InformationForPackageAuthors.html","id":"naming-rationalization-ast2ast","dir":"Articles","previous_headings":"","what":"Naming rationalization ast2ast","title":"Information for package authors","text":"nomenclature package, ast2ast, rooted abbreviation ast, signifying abstract syntax tree. Originally planned convert abstract syntax tree R C++ tree literature recommended transpilers. However, iterative refinement, optimal methodology emerged. development incorporated Expression Template Library C++ known ETR, meticulously crafted mimic R. Thus, R code translated ETR code, subsequently compiled. original ETR library accessible https://github.com/Konrad1991/ETR. ’s imperative note version integrated ast2ast undergone substantial enhancements, amplifying efficacy adaptability.","code":""},{"path":"/articles/InformationForPackageAuthors.html","id":"comparison-of-r-and-etr-code","dir":"Articles","previous_headings":"","what":"Comparison of R and ETR code","title":"Information for package authors","text":"Displayed basic bubble sort function implemented R left, juxtaposed ETR counterpart right. obvious two code snippets quite similar. Remarkably, overall structure R code remains unaltered. Instead, substitution individual functions ETR equivalents forms crux transformation. C++ code, functions located etr namespace. Certain functions share identical names R C++, length function. mitigate potential conflicts, calls modified explicitly reference etr namespace, resulting expressions like etr::length. functions example : [ defined C++ (least way used R) therefore replaced functions new names e.g. etr::colon etr::subset. Additionally, C++ necessitates explicit declaration variable types. Within example variables type sexp used. detailed explanation deferred subsequent section.","code":"bubbleSort <- function(a) {      size <- length(a)     for (i in 1:size) {       for (j in 1:(size - 1)) {         if (a[j] > a[j + 1]) {           temp <- a[j]           a[j] <- a[j + 1]           a[j + 1] <- temp         }       }     }   return(a) } // [[Rcpp::depends(ast2ast)]] // [[Rcpp::depends(RcppArmadillo)]] // [[Rcpp::plugins(cpp2a)]] #include \"etr.hpp\"  // [[Rcpp::export]] SEXP getXPtr();  sexp bubbleSort(sexp a) {    sexp size;    sexp temp;    size = etr::length(a);      for (auto&i:  etr::colon(etr::i2d(1), size)) {;           for (auto&j:  etr::colon(etr::i2d(1), (size - etr::i2d(1)))) {;               if (etr::subset(a, j) > etr::subset(a, j + etr::i2d(1))) {;                   temp = etr::subset(a, j);                   etr::subset(a, j) = etr::subset(a, j + etr::i2d(1));                  etr::subset(a, j + etr::i2d(1)) = temp;               };          };      };      return(a);   } SEXP getXPtr ()  {   typedef sexp (*fct_ptr) (sexp a);   return Rcpp::XPtr<fct_ptr>(new fct_ptr(&bubbleSort)); }"},{"path":[]},{"path":"/articles/InformationForPackageAuthors.html","id":"fundamental-type-in-expression-template-library-r-etr-vec-class","dir":"Articles","previous_headings":"Internals of ETR","what":"Fundamental Type in Expression Template Library R (ETR): Vec Class","title":"Information for package authors","text":"core type expression template library R (ETR) class called Vec. Presuming foundational familiarity classes templates C++, embark detailed exploration design inherent class. Vec class incorporates three templates, namely T, R, Trait. context, typename T signifies fundamental data type, R represents another class (details forthcoming). third template, Trait, plays crucial role endowing class identifiable properties Vec compile-time phase. majority instances, template T instantiated double, referred numeric context R types. certain occasions, T bool, denoted logical realm R types. typename R represents another class can either: Buffer, BorrowSEXP, Borrow, Subset, UnaryOperation BinaryOperation. classes contributes distinct functionalities features Vec class. recommended directly use classes Buffer, BorrowSEXP Borrow. Subset class yielded calls function subset. Whereas UnaryOperation BinaryOperation produced invoking functions like sin, cos, + -. hood, regardless whether represent dataframes, vectors, functions R type, variables type SEXP R. allusion fact basic type used variables called sexp. sexp alias Vec (etr::BaseType alias double). sexp class uses instance class Buffer manages memory variable. raw pointer form T* used. Thus, objects located heap. mentioned sections documentation R function can either translated R function calls C++ function external pointer C++ function. R function desired output form function expects arguments passed type SEXP furthermore function always returns element SEXP. Due class called WrapperSEXP introduced equivalent Vec<etr::BaseType, etr::BorrowSEXP>. Whenever, want use SEXP object C++ necessary construct object type WrapperSEXP assign SEXP object (see code snippet ). Notably, WrapperSEXP class works original memory section long increased size SEXP object. Thus, R objects can changed side effect, differs normal R behaviour increases performance. Moreover, object returned converted SEXP object. done function cpp2R. return statement found command return(R_NilValue); added code. Thereby, function returns NULL.","code":"SEXP handleSEXP(SEXP aSEXP) {    WrapperSEXP a; a = aSEXP;    /* rest of code*/    return(etr::cpp2R(a));   }"},{"path":"/articles/InformationForPackageAuthors.html","id":"the-xptr-interface","dir":"Articles","previous_headings":"Internals of ETR","what":"The XPtr interface","title":"Information for package authors","text":"contrast external pointer interface used broader range argument types can used. However, SEXP used. user translates function can choose : sexp, double, ptr_vec, ptr_mat BorrowPtr. arguments can either passed copy reference. handled boolean reference argument R. ptr_vec ptr_mat, two (vectors) three (matrices) arguments passed function. first one pointer pointing start memory area. case vec second argument type int defining size memory section. matrix two int arguments used defining number rows columns respectivly. case values copied elements passed sexp object copies memory section new one handled class. contrast elements passed reference object type BorrowPtr used. BorrowPtr alias Vec<etr::BaseType, etr::Borrow>. class BorrowPtr behaves way sexp object except resized. Thus, behaves wrapper around raw pointer providing convenience library. Moreover, memory section deleted end function. Therefore, user passes pointer size arguments handle memory . advantage something can written memory section side effect function efficient.","code":""},{"path":"/articles/InformationForPackageAuthors.html","id":"using-raw-pointers","dir":"Articles","previous_headings":"Internals of ETR > The XPtr interface","what":"Using raw pointers","title":"Information for package authors","text":"","code":"// [[Rcpp::depends(ast2ast)]] // [[Rcpp::depends(RcppArmadillo)]] // [[Rcpp::plugins(cpp2a)]] #include \"etr.hpp\"  sexp ptrVecCopy(etr::BaseType* a_double_ptr , int a_int_size) {    sexp a(a_double_ptr,a_int_size);     for (auto&i:  etr::colon(etr::i2d(1), etr::length(a))) {          etr::subset(a, i) = i * etr::i2d(2);          }    return(a); }  sexp ptrVecReference(etr::BaseType* a_double_ptr , int a_int_size) {    BorrowPtr a(a_double_ptr,a_int_size);     for (auto&i:  etr::colon(etr::i2d(1), etr::length(a))) {           etr::subset(a, i) = i * etr::i2d(2);          }    return(a); }  // [[Rcpp::export]] void callFct ()  {   int size = 3;   double* ptr = new double[size];   for(int i = 0; i < size; i++) ptr[i] = 0.0;   ptrVecCopy(ptr, size);   for(int i = 0; i < size; i++) Rcpp::Rcout << ptr[i] << \"\\t\";   Rcpp::Rcout << std::endl;   ptrVecReference(ptr, size);   for(int i = 0; i < size; i++) Rcpp::Rcout << ptr[i] << \"\\t\";   delete[] ptr; } callFct() ## 0    0   0    ## 2    4   6"},{"path":"/articles/InformationForPackageAuthors.html","id":"using-borrow","dir":"Articles","previous_headings":"Internals of ETR > The XPtr interface","what":"Using Borrow","title":"Information for package authors","text":"Instead passing raw pointer directly also possible pass wrapped class BorrowPtr. side note make difference whether argument passed reference . Furthermore, BorrowPtr returned function. example :","code":"// [[Rcpp::depends(ast2ast)]] // [[Rcpp::depends(RcppArmadillo)]] // [[Rcpp::plugins(cpp2a)]] #include \"etr.hpp\"  void otherFct(BorrowPtr a) {   subset(a, true) = 3.14; }  // [[Rcpp::export]] void callFct ()  {   int size = 3;   double* ptr = new double[size];   for(int i = 0; i < size; i++) ptr[i] = 0.0;   BorrowPtr a(ptr, size);   otherFct(a);   etr::print(a);   delete[] ptr; } callFct() ## 3.14 3.14 3.14"},{"path":"/articles/InformationForPackageAuthors.html","id":"using-sexp-instead-of-pointers","dir":"Articles","previous_headings":"Internals of ETR > The XPtr interface","what":"Using sexp instead of pointers","title":"Information for package authors","text":"Notably, thing can achieved sexp object without using raw pointers. code illustrate :","code":"// [[Rcpp::plugins(cpp2a)]] // [[Rcpp::depends(RcppArmadillo, ast2ast)]] #include \"etr.hpp\"  void byRef(sexp& a) {   for (auto&i:  etr::colon(etr::i2d(1), etr::length(a))) {         etr::subset(a, i) = i * etr::i2d(2);      } }  // [[Rcpp::export]] void call_fct() {   sexp a = etr::vector_numeric(3);   etr::print(a);   byRef(a);   etr::print(a); } call_fct() ## 0 0 0  ## 2 4 6"},{"path":"/articles/InformationForPackageAuthors.html","id":"thread-safety","dir":"Articles","previous_headings":"Internals of ETR","what":"Thread safety","title":"Information for package authors","text":"class Vec thread safe sense memory associated functions global variables. Moreover, almost static methods defined. exception methods used comparison. Notably, comparison methods (==, <=, >=, <, > !=) except two doubles (copy) arguments return bool. Thus, still possible use instances class parallel. However, user take care one thread edits object time.","code":""},{"path":"/articles/InformationForPackageAuthors.html","id":"conversions","dir":"Articles","previous_headings":"Internals of ETR","what":"Conversions","title":"Information for package authors","text":"sexp can converted Rcpp::NumericVectors, Rcpp::NumericMatrices, arma::vec arma::mat.","code":""},{"path":"/articles/InformationForPackageAuthors.html","id":"rcpp-interface","dir":"Articles","previous_headings":"Internals of ETR","what":"Rcpp Interface","title":"Information for package authors","text":"last section, usage ast2ast described. However, sexp variables defined. likely used package. Therefore interfaces common libraries defined. First , ast2ast can communicate Rcpp alleviates working library substantially. code shows possible pass sexp object variable type NumericVector NumericMatrix vice versa. , data always copied.","code":"// [[Rcpp::depends(ast2ast, RcppArmadillo)]] #include <RcppArmadillo.h> #include <Rcpp.h> // [[Rcpp::plugins(cpp2a)]] using namespace Rcpp; #include <etr.hpp> using namespace etr;  // [[Rcpp::export]] void fct() {   // NumericVector to sexp   NumericVector a{1, 2};   sexp a_ = a;   print(a_);      // sexp to NumericVector   sexp b_ = coca(3, 4);   NumericVector b = b_;   Rcpp::Rcout << b << std::endl;      // NumericMatrix to sexp   NumericMatrix c(3, 3);   sexp c_ = c;   print(c_);      // sexp to NumericMatrix   sexp d_ = matrix(colon(1, 16), 4, 4);   NumericMatrix d = d_;   Rcpp::Rcout << d << std::endl; } trash <- fct() ## 1 2  ## 3 4 ## 0    0   0    ## 0    0   0    ## 0    0   0    ## 1.00000 5.00000 9.00000 13.0000 ## 2.00000 6.00000 10.0000 14.0000 ## 3.00000 7.00000 11.0000 15.0000 ## 4.00000 8.00000 12.0000 16.0000"},{"path":"/articles/InformationForPackageAuthors.html","id":"rcpparmadillo-interface","dir":"Articles","previous_headings":"Internals of ETR","what":"RcppArmadillo Interface","title":"Information for package authors","text":"Besides Rcpp types, sexp objects can transfer data RcppArmadillo objects also possible copy data RcppArmadillo types sexp objects using operator =. code shows possible pass sexp object variable type vec mat vice versa. data always copied.","code":"// [[Rcpp::depends(ast2ast, RcppArmadillo)]] #include <RcppArmadillo.h> #include <Rcpp.h> // [[Rcpp::plugins(cpp2a)]] using namespace arma; #include <etr.hpp> using namespace etr;  // [[Rcpp::export]] void fct() {   // vec to sexp   arma::vec a(4, fill::value(30.0));   sexp a_ = a;   print(a_);      // sexp to vec   sexp b_ = coca(3, 4);   vec b = b_;   b.print();      // mat to sexp   mat c(3, 3, fill::value(31.0));   sexp c_ = c;   print(c_);      // sexp to mat   sexp d_ = matrix(colon(1, 16), 4, 4);   mat d = d_;   d.print(); } trash <- fct() ## 30 30 30 30  ##    3.0000 ##    4.0000 ## 31   31  31   ## 31   31  31   ## 31   31  31   ##     1.0000    5.0000    9.0000   13.0000 ##     2.0000    6.0000   10.0000   14.0000 ##     3.0000    7.0000   11.0000   15.0000 ##     4.0000    8.0000   12.0000   16.0000"},{"path":"/articles/InformationForPackageAuthors.html","id":"how-to-use-the-xptr-interface","dir":"Articles","previous_headings":"","what":"How to use the XPtr interface","title":"Information for package authors","text":"paragraph, basic example demonstrates write R code, translate external pointer call C++. Particular emphasis placed C++ code. First , R function defined accepts one argument called , adds two stores b. variable b returned end function. R function called f translated external pointer C++ function. C++ function depends RcppArmadillo ast2ast therefore required macros headers included. Moreover, ETR requires std=c++20 therefore corresponding plugin added. function getXPtr defined function available R. Subsequently, actual translated code depicted. function f returns sexp gets one argument type sexp called . body function looks almost identical R function. Except variable b defined first line body type sexp. function i2d converts integer double variable. necessary since C++ identify 2 integer user wants case. Afterwards, translated R function used C++ code. package code example. First, macros defined RcppArmadillo ast2ast. Subsequently, necessary header files included. already mentioned ast2ast requires std=c++20 thus required plugin included. use function, necessary dereference pointer. result dereferenced pointer stored function pointer. Later function pointer can used call translated function. Therefore, function pointer called fp defined. critical signature function pointer matches one translated function. Perhaps good idea check R function produced C++ code translated. defining function pointer, function defined called later user (called call_package). function accepts external pointer. Within function body, variable f defined type fp inp assigned . Next, sexp object called defined stores vector length 3 containing 1, 2 3. function coca equivalent c function R. Afterwards printed. Followed call function f storing result . variable printed show values changed according code defined R function. user can call now package code pass R function . Thus, user install compiler Rtools depending operating system. necessary write function Rcpp.","code":"f <- function(a) {   b <- a + 2   return(b) }   library(ast2ast) f_cpp <- translate(f, output = \"XPtr\", return_type = \"etr::Vec<double>\") // [[Rcpp::depends(ast2ast, RcppArmadillo)]] // [[Rcpp::plugins(cpp2a)]] #include <etr.hpp>  // [[Rcpp::export]] SEXP getXPtr();  sexp f(sexp a) {   sexp b;   b = a + etr::i2d(2);   return(b); } SEXP getXPtr ()  {   typedef sexp (*fct_ptr) (sexp a);   return Rcpp::XPtr<fct_ptr>(new fct_ptr(&f)); } // [[Rcpp::depends(RcppArmadillo, ast2ast)]] // [[Rcpp::plugins(\"cpp2a\")]] #include \"etr.hpp\"  typedef etr::Vec<double> (*FP)(etr::Vec<double> a);  // [[Rcpp::export]] void call_package(Rcpp::XPtr<FP> inp) {   FP f = *inp;   sexp a = etr::coca(1, 2, 3);   etr::print(a);   a = f(a);   etr::print(\"a is now:\");   etr::print(a); } call_package(f_cpp) ## 1 2 3  ## a is now: ##  ## 3 4 5"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Krämer Konrad. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Konrad K (2024). ast2ast: Translates R Function C++ Function. R package version 0.4, https://github.com/Konrad1991/ast2ast.","code":"@Manual{,   title = {ast2ast: Translates an R Function to a C++ Function},   author = {Krämer Konrad},   year = {2024},   note = {R package version 0.4},   url = {https://github.com/Konrad1991/ast2ast}, }"},{"path":"/reference/J.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"R function translated C++ source code afterwards code compiled.    result can external pointer (XPtr) R function.    default value R function.    information can found vignette: Detailed Documentation.","code":""},{"path":"/reference/J.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"","code":"J(     f,     y,     x,     output = \"R\",     types_of_args = \"SEXP\",     return_type = \"SEXP\",     reference = FALSE,     verbose = FALSE,     getsource = FALSE   )"},{"path":"/reference/J.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"f function translated R C++. y variables compute derivatives (dependent variable). example: df/dx x variables respect variables calcualted (independent variable). example: df/dx output set \"R\"\" R function wrapping C++ code returned.      output set \"XPtr\"\" external pointer object pointing C++ code returned.      default value \"R\". types_of_args define types arguments passed function character vector.      optional input using \"XPtr\" output.      default value \"SEXP\" possibility output \"R\".      case one want use external pointer easiest way pass \"sexp\" types_of_args.      Beyond possible pass \"double\", \"ptr_vec\" \"ptr_mat\".     information see details check vignette InformationForPackageAuthors.     Beyond , aware passed SEXP objects copied object size increases.       Thus, R objects can modified within function! See section details example return_type character defining type function returns. default value \"SEXP\"\" possibility output \"R\".      Additionally, possibilities \"sexp\" \"void\" exist external pointer interface. reference set TRUE arguments passed reference (possible output \"R\"). verbose set TRUE output compilation process printed. getsource set TRUE function compiled instead C++ source code returned.","code":""},{"path":"/reference/J.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"output set R R function returned. Thus, C++ code can directly called within R. contrast function returns external pointer generated output set XPtr.","code":""},{"path":"/reference/J.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"types numeric vector numeric matrix supported.     Notably, possible variables change type within function. Beyond , aware passed SEXP objects copied size increases. Thus, R objects can modified within function!      example following code variable contains 1, 2, 3 function call afterwards 1, 1 1.     contrast variable b size changes thus object within R modified. Furthermore, variable c increased first element         changed.      f <- function(, b, c) {        [c(1, 2, 3)] <- 1        b <- vector(10)        c <- vector(1)     }      fcpp <- ast2ast::translate(f)      <- c(1, 2, 3)      b <- c(1, 2, 3)      c <- c(1, 2, 3)     fcpp(, b,c)      print()      print(b)      print(c)      possible declare variable scalar numeric data type.     done adding _db end variable. time _db found     variable declared scalar numeric data type. case     object change type! example variable a_db type double whereas b type \"sexp\".      f <- function() {       a_db = 3.14       b = 3.14     }     fcpp <- ast2ast::translate(f, verbose = TRUE)     fcpp()       R every object hood SEXP object.   case R function created output SEXP elements can passed function.    Furthermore, functions always return SEXP element. Even nothing returned; case NULL returned!.    Notably, numeric vectors (R also scalar values vectors) numeric matrices can passed function.    contrast external pointer created types can specified passed function returned .    default value variable type sexp. data type used C++ code.    ptr_vec ptr_mat interface work different way. using ptr_vec double* pointer expected first element.   Additionally second argument needed type int defines size array.    works way ptr_mat. instead size argument two integers needed define number rows columns.   arguments type int.    Notably, memory borrowed. Thus, memory automatically deleted! See vignette InformationForPackageAuthors information. following functions supported: assignment: = <- allocation: vector matrix information objects: length dim Basic operations: +, -, *, / Indices: '[]'. function '' used! Beyond integer values allowed within brackets. mathematical functions: sin, asin, sinh, cos, acos, cosh, tan, atan, tanh, sqrt, log, ^ exp concatenate objects: c control flow: , , else , else comparison: ==, !=, >, <, >= <= printing: print returning objects: return catmull-rome spline: cmr get range numbers ':' function can used .na .infinite can used test NA Inf. details see: dfdr::jacobian()","code":""},{"path":"/reference/J.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the jacobian function and translatesthe resulting function into a C++ function. — J","text":"","code":"# Further examples can be found in the vignettes.    if (FALSE) {       # simple example       f <- function(y) {         ydot <- vector(length = 2)         a <- 1.1         b <- 0.4         c <- 0.1         d <- 0.4         ydot[1] <- y[1]*a - y[1]*y[2]*b         ydot[2] <- y[2]*y[1]*c - y[2]*d         return(ydot)       }       jac <- ast2ast::J(f, ydot, y, verbose = TRUE)       jac(c(10, 11))   }"},{"path":"/reference/translate.html","id":null,"dir":"Reference","previous_headings":"","what":"Translates an R function into a C++ function. — translate","title":"Translates an R function into a C++ function. — translate","text":"R function translated C++ source code afterwards code compiled.    result can external pointer (XPtr) R function.    default value R function.    information can found vignette: Detailed Documentation.","code":""},{"path":"/reference/translate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translates an R function into a C++ function. — translate","text":"","code":"translate(     f,     output = \"R\",     types_of_args = \"SEXP\",     return_type = \"SEXP\",     reference = FALSE,     verbose = FALSE,     getsource = FALSE   )"},{"path":"/reference/translate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translates an R function into a C++ function. — translate","text":"f function translated R C++. output set \"R\"\" R function wrapping C++ code returned.      output set \"XPtr\"\" external pointer object pointing C++ code returned.      default value \"R\". types_of_args define types arguments passed function character vector.      optional input using \"XPtr\" output.      default value \"SEXP\" possibility output \"R\".      case one want use external pointer easiest way pass \"sexp\" types_of_args.      Beyond possible pass \"double\", \"ptr_vec\" \"ptr_mat\".     information see details check vignette InformationForPackageAuthors.     Beyond , aware passed SEXP objects copied object size increases.       Thus, R objects can modified within function! See section details example return_type character defining type function returns. default value \"SEXP\"\" possibility output \"R\".      Additionally, possibilities \"sexp\" \"void\" exist external pointer interface. reference set TRUE arguments passed reference (possible output \"R\"). verbose set TRUE output compilation process printed. getsource set TRUE function compiled instead C++ source code returned.","code":""},{"path":"/reference/translate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translates an R function into a C++ function. — translate","text":"output set R R function returned. Thus, C++ code can directly called within R. contrast function returns external pointer generated output set XPtr.","code":""},{"path":"/reference/translate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translates an R function into a C++ function. — translate","text":"types numeric vector numeric matrix supported.     Notably, possible variables change type within function. Beyond , aware passed SEXP objects copied size increases. Thus, R objects can modified within function!      example following code variable contains 1, 2, 3 function call afterwards 1, 1 1.     contrast variable b size changes thus object within R modified. Furthermore, variable c increased first element         changed.      f <- function(, b, c) {        [c(1, 2, 3)] <- 1        b <- vector(10)        c <- vector(1)     }      fcpp <- ast2ast::translate(f)      <- c(1, 2, 3)      b <- c(1, 2, 3)      c <- c(1, 2, 3)     fcpp(, b,c)      print()      print(b)      print(c)      possible declare variable scalar numeric data type.     done adding _db end variable. time _db found     variable declared scalar numeric data type. case     object change type! example variable a_db type double whereas b type \"sexp\".      f <- function() {       a_db = 3.14       b = 3.14     }     fcpp <- ast2ast::translate(f, verbose = TRUE)     fcpp()       R every object hood SEXP object.   case R function created output SEXP elements can passed function.    Furthermore, functions always return SEXP element. Even nothing returned; case NULL returned!.    Notably, numeric vectors (R also scalar values vectors) numeric matrices can passed function.    contrast external pointer created types can specified passed function returned .    default value variable type sexp. data type used C++ code.    ptr_vec ptr_mat interface work different way. using ptr_vec double* pointer expected first element.   Additionally second argument needed type int defines size array.    works way ptr_mat. instead size argument two integers needed define number rows columns.   arguments type int.    Notably, memory borrowed. Thus, memory automatically deleted! See vignette InformationForPackageAuthors information. following functions supported: assignment: = <- allocation: vector matrix information objects: length dim Basic operations: +, -, *, / Indices: '[]' mathematical functions: sin, asin, sinh, cos, acos, cosh, tan, atan, tanh, sqrt, log, ^ exp concatenate objects: c control flow: , , else , else comparison: ==, !=, >, <, >= <= printing: print returning objects: return catmull-rome spline: cmr get range numbers ':' function can used .na .infinite can used test NA Inf. d-, p-, q- r-unif, -norm, -lnorm -gamma (gamma argument Scale defined calculated using 1/rate) details implemented functions allocation memory works: Following forms possible: vector(size_of_elements) vector(value, size_of_elements) matrix(nrows, ncols) matrix(value, nrows, ncols) matrix(vector, nrows, ncols) indices squared brackets '[]' can used common R. Beyond function '' exists     accepts first argument variable second argument pass desired index.     caveat using '' one entry can accessed. function '[]' can return one element. -function returns reference vector entry.       Therefore variable[index] can behave differently (variable, index).       integers found within '[]' function used right side assignment operator (=).       -function can also used left side assignment operator. However, case        used right side. Otherwise results wrong.              small example presented use subset functions:                f <- function() {           <- c(1, 2, 3)           print((, 1))           print([1:2])         }         fcpp <- ast2ast::translate(f)         fcpp() -loops can written common R Nr.1        (index variable){          # whatever          } Nr.2        (index 1:length(variable){          # whatever          } aware possible assign result comparison variable. Example see :      However, vector contain 0 1 instead FALSE TRUE.            = c(1, 2, 3)       b = c(1, 2, 1)       c = != b print function accepts either scalar, vector, matrix, string, bool nothing (empty line). order return object use return function (last object returned automatically R). order interpolate values cmr function can used. function needs three arguments. first argument point independent variable (x) dependent variable calculated (y). vector length one. second argument vector defining points independent variable (x). vector least length four. third argument vector defining points dependent variable (y). vector least length four. aware R code translated ETR expression template library tries mimic R.        However, behave exactly like R! Please check compiled function using serious project.       want see ast2ast differs R detail check vignette: Detailed Documentation.","code":""},{"path":"/reference/translate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translates an R function into a C++ function. — translate","text":"","code":"# Further examples can be found in the vignettes.      if (FALSE) {       # Hello World       # ==========================================================================              # Translating to R_fct       # --------------------------------------------------------------------------       f <- function() { print(\"Hello World!\")}       ast2ast::translate(f)       f()              # Translating to external pointer       # --------------------------------------------------------------------------       f <- function() { print(\"Hello World!\")}       pointer_to_f_cpp <- ast2ast::translate(f,                                               output = \"XPtr\", return_type = \"void\")       Rcpp::sourceCpp(code = '       #include <Rcpp.h>       typedef void (*fp)();        // [[Rcpp::export]]       void call_fct(Rcpp::XPtr<fp> inp) {         fp f = *inp;         f(); } ')                call_fct(pointer_to_f_cpp)              # Run sum example:       # ==========================================================================              # R version of run sum       # --------------------------------------------------------------------------       run_sum <- function(x, n) {         sz <- length(x)                  ov <- vector(mode = \"numeric\", length = sz)                  ov[n] <- sum(x[1:n])         for(i in (n+1):sz) {                      ov[i] <- ov[i-1] + x[i] - x[i-n]         }                  ov[1:(n-1)] <- NA                  return(ov)       }              # translated Version of R function       # --------------------------------------------------------------------------       run_sum_fast <- function(x, n) {         sz <- length(x)         ov <- vector(sz)                  sum_db = 0         for(i in 1:n) {           sum_db <- sum_db + at(x, i)         }         ov[n] <- sum_db                  for(i in (n + 1):sz) {           ov[i] <- at(ov, i - 1) + at(x, i) - at(x, i - at(n, 1))         }                  ov[1:(n - 1)] <- NA                  return(ov)       }       run_sum_cpp <- ast2ast::translate(run_sum_fast, verbose = FALSE)       set.seed(42)       x <- rnorm(10000)       n <- 500       one <- run_sum(x, n)       two <- run_sum_cpp(x, n)     }"}]
