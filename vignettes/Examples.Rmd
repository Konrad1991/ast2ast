---
title: "Examples"
author: "Konrad KrÃ¤mer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Examples}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## How to use *ast2ast*

### R code is translated

```{r}
add_two <- function(a) {
  return(a + 2)
}  
pointer_to_f_cpp <- ast2ast::translate(add_two)
```

### Defining C++ Code which uses the translated R Code

```{Rcpp}
// [[Rcpp::depends(ast2ast)]]
// [[Rcpp::depends(RcppArmadillo)]]
#include "etr.hpp"

// [[Rcpp::plugins("cpp17")]]

typedef sexp (*fp)(sexp a);

// [[Rcpp::export]]
void call_fct(Rcpp::XPtr<fp> inp) {
  fp f = *inp;
  sexp a = coca(1, 2, 3);
  print(a);
  a = f(a);
  print("a is now:");
  print(a);
}
```

### Calling the final function

```{r}
#Rcpp::sourceCpp("cpp_code.cpp") # if not run in Rmarkdown
call_fct(pointer_to_f_cpp)
```



## Using *ast2ast* in combination with *r2sundials*

### *r2sundials* code

```{r}
setwd("/home/konrad/Documents/0Uni/programming")
#install.packages("ast2ast", type = "source", repos = NULL)

library(Rcpp)
library(ast2ast)
library(r2sundials)
library(RcppXPtrUtils)
library(microbenchmark)


# R version
ti <- seq(0, 5, length.out=101)
p <- list(a = 2)
p <- c(nu = 2, a = 1)
y0 <- 0
frhs <- function(t, y, p, psens) -p["nu"]*(y-p["a"])

res_exp <- r2sundials::r2cvodes(y0, ti, frhs, param = p)
attributes(res_exp) <- NULL
#stopifnot(diff(range(1-exp(-p$a*ti) - res_exp)) < 1.e-6)


# External pointer
ptr_exp <- cppXPtr(code = '
int rhs_exp(double t, const vec &y, vec &ydot, RObject &param, NumericVector &psens) {
  double a = 1;
  double nu = 2;
  ydot[0] = -nu*(y[0] - a);
  return(CV_SUCCESS);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes="using namespace arma;\n#include <r2sundials.h>", cacheDir="lib", verbose=FALSE)
pv <- c(a = 1)
res_exp2 <- r2sundials::r2cvodes(y0, ti, ptr_exp, param = pv)
attributes(res_exp2) <- NULL
```

### Wrapper code in order to call translated R function (maybe written by package authors)

```{Rcpp}
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::depends(rmumps)]]
// [[Rcpp::depends(r2sundials)]]
// [[Rcpp::depends(ast2ast)]]
// [[Rcpp::plugins("cpp17")]]
#include "etr.hpp"
#include "RcppArmadillo.h"
#include "r2sundials.h"
using namespace arma;

typedef int (*fp)(double t, const vec &y, vec &ydot, RObject &param, NumericVector &psens);

typedef void (*user_fct)(sexp& y_, sexp& ydot_);
user_fct Fct;

int rhs_exp_wrapper(double t, const vec &y, vec &ydot, RObject &param, NumericVector &psens) {
  NumericVector p(param);
  const int size = y.size();
  sexp ydot_(size, ydot.memptr(), 2);
  double* ptr = const_cast<double*>(y.memptr());
  sexp y_(size, ptr, 2);
  Fct(y_, ydot_);
  return(CV_SUCCESS);
}



// [[Rcpp::export]]
Rcpp::NumericVector solve_ode(Rcpp::XPtr<user_fct> inp, NumericVector time, NumericVector y) {
  Fct = *inp;
  Rcpp::XPtr<fp> ptr = Rcpp::XPtr<fp>(new fp(&rhs_exp_wrapper));

  Rcpp::Environment pkg = Rcpp::Environment::namespace_env("r2sundials");
  Rcpp::Function solve = pkg["r2cvodes"];

  Rcpp::NumericVector output = solve(y, time, ptr, time);

  return output;
}
```


### Applying *ast2ast*

The speed of pure C++ is not reached. However, the *ast2ast* function is substantially fastern then the R code. 

```{r}
# ast2ast version
ti <- seq(0, 5, length.out=101)
p <- list(a = 2)
p <- c(nu = 2, a = 1)
y0 <- 0

ode <- function(y, ydot) {
  nu <- 2
  a <- 1
  ydot <- -nu*(y - a)
}

ode <- function(y, ydot) {
  nu <- 2
  a <- 1
  ydot[1] <- -nu*(y[1] - a)
}

pointer_to_ode <- ast2ast::translate(ode, reference = TRUE, verbose = FALSE)
res_exp3 <- solve_ode(pointer_to_ode, ti, y0)
attributes(res_exp3) <- NULL

head(res_exp)
head(res_exp2)
head(res_exp3)

microbenchmark(r2cvodes(y0, ti, frhs, param = p), r2cvodes(y0, ti, ptr_exp, param = pv), solve_ode(pointer_to_ode, ti, y0))
```






















## Using *ast2ast* in combination with *paropt*

```{Rcpp}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::depends(ast2ast)]]
// [[Rcpp::plugins("cpp17")]]
// [[Rcpp::depends(paropt)]]
#include "etr.hpp"
#include "RcppArmadillo.h"
using namespace Rcpp;

typedef int (*OS)(double &t, std::vector<double> &params, std::vector<double> &states);

int ode_system(double &t, std::vector<double> &params, std::vector<double> & states) {
  double a = params[0];
  double b = params[1];
  double c = params[2];
  double d = params[3];

  double n1 = states[0];
  double n2 = states[1];

  states[0] = n1*c*n2 - n1*d;
  states[1] = n2*a - n2*b*n1;

  return 0;
}

// [[Rcpp::export]]
Rcpp::XPtr<OS> test_optimization() {
  Rcpp::XPtr<OS> xpfun = Rcpp::XPtr<OS>(new OS(&ode_system));
  return xpfun;
}


typedef int (*paropt_fct)(double &t, std::vector<double> &params, std::vector<double> & states);

typedef void (*user_fct2)(sexp& p, sexp& y);

user_fct2 Fct_paropt;

int ode_system_wrapper(double &t, std::vector<double> &params, std::vector<double> & states) {
  sexp p(params.size(), params.data(), 2);
  sexp s(states.size(), states.data(), 2);
  Fct_paropt(p, s);

  return 0;
}


// [[Rcpp::export]]
Rcpp::List optimize_paropt(Rcpp::XPtr<user_fct2> inp,
                                    NumericVector time, Rcpp::DataFrame lb, Rcpp::DataFrame ub, Rcpp::DataFrame states) {
  Fct_paropt = *inp;
  Rcpp::XPtr<paropt_fct> ptr = Rcpp::XPtr<paropt_fct>(new paropt_fct(&ode_system_wrapper));

  Rcpp::Environment pkg = Rcpp::Environment::namespace_env("paropt");
  Rcpp::Function optim = pkg["optimizer_pointer"];

  Rcpp::NumericVector abs_tols{1e-8, 1e-8};

  Rcpp::List output = optim(time, ptr, 1e-6, abs_tols, lb, ub, states,
                                    40, 1000, 0.0001, "bdf");

  return output;
}
```


```{r}
#states
path <- system.file("examples", package = "paropt")
states <- read.table(paste(path,"/states_LV.txt", sep = ""), header = T)

# parameter
lb <- data.frame(time = 0, a = 0.8, b = 0.3, c = 0.09, d = 0.09)
ub <- data.frame(time = 0, a = 1.3, b = 0.7, c = 0.4, d = 0.7)

# Optimizing
library(paropt)
set.seed(1)
start_time <- Sys.time()
df <- optimizer_pointer(integration_times = states$time, ode_sys = test_optimization(),
                        relative_tolerance = 1e-6, absolute_tolerances = c(1e-8, 1e-8),
                       lower = lb, upper = ub, states = states,
                       npop = 40, ngen = 1000, error = 0.0001, solvertype = "bdf")
end_time <- Sys.time()
end_time - start_time
#df

# ast2ast
ode <- function(params, states) {
  a = params[1]
  b = params[2]
  c = params[3]
  d = params[4]

  n1 = states[1];
  n2 = states[2];

  states[1] = n1*c*n2 - n1*d;
  states[2] = n2*a - n2*b*n1;
}

pointer_to_ode <- ast2ast::translate(ode, reference = TRUE, verbose = FALSE)
set.seed(1)
start_time <- Sys.time()
df2 <- optimize_paropt(pointer_to_ode, states$time, lb, ub, states)
end_time <- Sys.time()
end_time - start_time








# ast2ast with at
ode <- function(params, states) {
  a = at(params, 1)
  b = at(params, 2)
  c = at(params, 3)
  d = at(params, 4)

  n1 = at(states, 1)
  n2 = at(states, 2)

  states[1] = n1*c*n2 - n1*d;
  states[2] = n2*a - n2*b*n1;
}

pointer_to_ode <- ast2ast::translate(ode, reference = TRUE, verbose = FALSE)
set.seed(1)
start_time <- Sys.time()
df3 <- optimize_paropt(pointer_to_ode, states$time, lb, ub, states)
end_time <- Sys.time()
end_time - start_time






# ast2ast with only at
ode <- function(params, states) {
  a = at(params, 1)
  b = at(params, 2)
  c = at(params, 3)
  d = at(params, 4)

  n1 = at(states, 1)
  n2 = at(states, 2)

  at(states, 1) = at(n1, 1)*at(c, 1)*at(n2, 1) - at(n1, 1)*at(d, 1);
  at(states, 2)= at(n2, 1)*at(a, 1) - at(n2, 1)*at(b, 1)*at(n1, 1);
}

pointer_to_ode <- ast2ast::translate(ode, reference = TRUE, verbose = FALSE)
set.seed(1)
start_time <- Sys.time()
df3 <- optimize_paropt(pointer_to_ode, states$time, lb, ub, states)
end_time <- Sys.time()
end_time - start_time


df[[8]]
df2[[8]]
df3[[8]]
```





